import os
import io
import uuid
from hashlib import sha256

from flask import (
    Flask,
    render_template,
    request,
    send_file,
    redirect,
    url_for,
    abort,
    flash,
)
from werkzeug.utils import secure_filename
from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from dotenv import load_dotenv

# Load environment variables from .env
load_dotenv()

app = Flask(__name__)

# Flask config
app.config["UPLOAD_FOLDER"] = "uploads"
app.config["MAX_CONTENT_LENGTH"] = 100 * 1024 * 1024  # 100 MB limit
app.config["SECRET_KEY"] = os.getenv("FLASK_SECRET_KEY", os.urandom(32))

os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# Allowed file extensions (you can adjust this list)
ALLOWED_EXTENSIONS = {
    "txt",
    "pdf",
    "png",
    "jpg",
    "jpeg",
    "gif",
    "zip",
    "docx",
    "xlsx",
}

# In-memory storage for file metadata:
# file_keys[encrypted_name] = {
#   "original_name": str,
#   "key_token": str,
#   "sha256": str
# }
# In a real app you would use a database
file_keys = {}


def allowed_file(filename: str) -> bool:
    """Check if the uploaded file has an allowed extension."""
    if "." not in filename:
        return False
    ext = filename.rsplit(".", 1)[1].lower()
    return ext in ALLOWED_EXTENSIONS


def get_master_fernet() -> Fernet:
    """
    Return a Fernet instance based on the MASTER_KEY stored in .env.

    MASTER_KEY must be a valid Fernet key (i.e., generated by Fernet.generate_key()).
    """
    master_key = os.getenv("MASTER_KEY")
    if not master_key:
        raise RuntimeError("MASTER_KEY not set in .env file!")

    try:
        return Fernet(master_key)
    except Exception as exc:
        raise RuntimeError("MASTER_KEY is not a valid Fernet key!") from exc


def encrypt_file(input_path: str, output_path: str) -> tuple[str, str]:
    """
    Encrypt a file using AES-256-CBC + PKCS7 padding.

    Returns:
        (encrypted_aes_key_token_str, sha256_hex)
    """
    # Generate per-file AES-256 key and IV
    aes_key = os.urandom(32)
    iv = os.urandom(16)

    # Read the file contents
    with open(input_path, "rb") as f:
        plaintext = f.read()

    # Compute SHA-256 hash of the original plaintext for integrity checking
    file_hash = sha256(plaintext).hexdigest()

    # Encrypt the file with AES-256-CBC + PKCS7 padding
    cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
    encryptor = cipher.encryptor()

    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plaintext) + padder.finalize()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()

    # Encrypt the per-file AES key with the master Fernet key (envelope encryption)
    fernet = get_master_fernet()
    encrypted_aes_key_token = fernet.encrypt(aes_key)  # bytes (Fernet token)

    # Store: IV (16) + encrypted_aes_key_token + ciphertext
    with open(output_path, "wb") as f:
        f.write(iv + encrypted_aes_key_token + ciphertext)

    # Return the Fernet token as string for easy storage
    return encrypted_aes_key_token.decode("utf-8"), file_hash


def decrypt_to_bytes(encrypted_path: str, encrypted_key_token_str: str) -> bytes:
    """
    Decrypt the encrypted file at encrypted_path using the stored key token.

    Returns:
        plaintext bytes

    Raises:
        RuntimeError if decryption fails for any reason.
    """
    token_bytes = encrypted_key_token_str.encode("utf-8")

    with open(encrypted_path, "rb") as f:
        file_data = f.read()

    # First 16 bytes = IV
    iv = file_data[:16]
    token_len = len(token_bytes)
    ciphertext = file_data[16 + token_len :]

    fernet = get_master_fernet()

    try:
        aes_key = fernet.decrypt(token_bytes)
    except InvalidToken as exc:
        # Master key changed or token corrupted
        raise RuntimeError("Failed to unwrap AES key (invalid token).") from exc

    cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
    decryptor = cipher.decryptor()
    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

    unpadder = padding.PKCS7(128).unpadder()
    try:
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    except ValueError as exc:
        # Padding error => ciphertext tampered or wrong key/iv
        raise RuntimeError("Failed to unpad plaintext (possible tampering).") from exc

    return plaintext


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/upload", methods=["GET", "POST"])
def upload():
    if request.method == "POST":
        file = request.files.get("file")

        if not file or file.filename == "":
            flash("No file selected.", "error")
            return redirect(request.url)

        original_name = secure_filename(file.filename)

        if not allowed_file(original_name):
            flash("File type not allowed.", "error")
            return redirect(request.url)

        # Save to temporary path first
        temp_path = os.path.join(
            app.config["UPLOAD_FOLDER"], f"temp_{uuid.uuid4().hex}"
        )
        file.save(temp_path)

        # Final encrypted filename (random)
        encrypted_name = uuid.uuid4().hex
        encrypted_path = os.path.join(app.config["UPLOAD_FOLDER"], encrypted_name)

        try:
            key_token_str, file_hash = encrypt_file(temp_path, encrypted_path)
        except Exception as exc:
            # Clean up temp file if something goes wrong
            if os.path.exists(temp_path):
                os.remove(temp_path)
            flash(f"Encryption failed: {exc}", "error")
            return redirect(request.url)
        finally:
            # Best-effort cleanup of temp file
            if os.path.exists(temp_path):
                os.remove(temp_path)

        # Store metadata in memory (in real app, use DB)
        file_keys[encrypted_name] = {
            "original_name": original_name,
            "key_token": key_token_str,
            "sha256": file_hash,
        }

        flash("File uploaded and encrypted successfully.", "success")
        return redirect(url_for("files"))

    return render_template("upload.html")


@app.route("/files")
def files():
    # Convert in-memory dict to list for template
    file_list = [
        {"id": enc_name, "name": data["original_name"]}
        for enc_name, data in file_keys.items()
    ]
    return render_template("files.html", files=file_list)


@app.route("/download/<file_id>")
def download(file_id):
    file_meta = file_keys.get(file_id)
    if not file_meta:
        abort(404)

    original_name = file_meta["original_name"]
    key_token_str = file_meta["key_token"]
    expected_hash = file_meta["sha256"]

    encrypted_path = os.path.join(app.config["UPLOAD_FOLDER"], file_id)

    if not os.path.exists(encrypted_path):
        abort(404)

    try:
        decrypted_data = decrypt_to_bytes(encrypted_path, key_token_str)
    except RuntimeError as exc:
        # Decryption or integrity failure
        flash(f"Decryption failed: {exc}", "error")
        abort(500)

    # Integrity check: compare SHA-256 of decrypted data to stored hash
    actual_hash = sha256(decrypted_data).hexdigest()
    if actual_hash != expected_hash:
        flash("File integrity check failed. Download aborted.", "error")
        abort(500)

    return send_file(
        io.BytesIO(decrypted_data),
        as_attachment=True,
        download_name=original_name,
        mimetype="application/octet-stream",
    )


if __name__ == "__main__":
    # In production, DEBUG should always be False
    app.run(debug=True)
